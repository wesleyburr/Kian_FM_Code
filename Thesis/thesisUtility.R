library(multitaper)
library(VGAM)
dyn.load("f95Lib.so")

dpssap <- function(V, maxdeg, alpha=0.75) {
  
  # Sanity checks
  stopifnot(is.matrix(V), is.numeric(maxdeg), maxdeg>=0)
  N <- length(V[, 1])
  K <- length(V[1, ])
  P <- maxdeg + 1
  timeArr <- 1:N
  
  R <- matrix(data=0, nrow=N, ncol=P)
  U <- matrix(data=0, nrow=K, ncol=P)
  
  # Setup centered time index
  midTime <- (1+N) / 2
  scl <- 2/(N-1)
  timeArrC <- (timeArr - midTime) * scl
  
  # Start with Gegenbauer polynomials; convergence is faster
  R[, 1] <- 1.0
  if(maxdeg > 0) {
    R[, 2] <- 2 * alpha * timeArrC
    if(maxdeg > 1) {
      for(j in 2:maxdeg) {
        A1 <- 2 * ( (j-1) + alpha ) / j
        A2 <- ( (j-2) + 2 * alpha ) / j
        
        R[, (j+1)] <- A1 * timeArrC * R[, j] - A2 * R[, (j-1)]
      } # end of loop on higher orders
    } # end of maxdeg > 1
  } # end of maxdeg > 0
  
  # Inner Products of R and V
  for(L in 1:P) {
    Kmin <- ( (L-1) %% 2 ) + 1
    for(k in seq(Kmin, K, 2)) {  # loop on non-zero Slepians
      U[k, L] <- t(V[, k]) %*% R[, L]
    }
  }
  
  # Degree 0, 1 (manual) -- L = degree+1
  for(L in 1:min(2,P)) {
    scl <- 1 / sqrt( sum(U[, L]^2) )
    U[, L] <- U[, L] * scl # orthonormalize
    R[, L] <- R[, L] * scl
  }
  
  # loop on higher degrees, applying Gram-Schmidt only on similar
  # parity functions (as even/odd are already orthogonal in U)
  if( P > 2 ) {
    for(L in 3:P) {
      if(L %% 2 == 0) {
        Kmin <- 2
      } else {
        Kmin <- 1
      }
      for(j in seq(Kmin, L-1, 2)) {
        scl <- sum( U[, L] * U[, j] )
        U[, L] <- U[, L] - scl * U[, j] # Gram-Schmidt
        R[, L] <- R[, L] - scl * R[, j]
      }
      scl <- 1 / sqrt(sum(U[, L]^2))
      U[, L] <- U[, L] * scl  # orthonormalize
      R[, L] <- R[, L] * scl
    }
  }
  
  Hn <- colSums(R^2)
  ap <- list(U=U,R=R,Hn=Hn)
  class(ap) <- "ass.poly"
  return(ap)
}



filterDesign <- function(nflt, ndec = NULL, M = 2^14, wflt = NULL){
  if ((is.null(ndec) & is.null(wflt)) | (!is.null(ndec) & !is.null(wflt))){
    stop("You must set one and only one of ndec or wflt.")
  }
  
  fudge <- 1.1 # deals with passband of the filter
  if (is.null(wflt)){
    wflt <- 0.5 * fudge / ndec
  } else {
    ndec <- ceiling(0.5/wflt)
    wflt <- wflt * fudge
  }
  nw <- floor(nflt*wflt)
  k <- 2*nw - 3
  nfreq <- 1 + M/2
  # generate slepians, keep even ordered ones
  slep.tmp <- multitaper::dpss(n = nflt, k = k, nw = nw, returnEigenvalues = FALSE)$v[, seq(1, k, by = 2)]
  
  neh <- (nflt-1)/2
  nc <- neh + 1
  
  # # how *I* think it should be ... 
  slep <- matrix(0, nrow = M, ncol = ncol(slep.tmp))
  
  slep[1, ] <- slep.tmp[nc, ]
  slep[2:(neh+1), ] <- slep[M:(M-neh+1), ] <- slep.tmp[(nc + 1):nflt, ]
  
  taper <- mvfft(slep)[1:nfreq, ]
  taper.real <- Re(taper)
  freq <- seq(0, 0.5, by = 1/M)
  
  fCut1 <- tail(which(freq <= wflt), 1)
  fCut <- trunc(min(fCut1, 0.85 * M / (2*ndec))) ### This is the important piece!
  
  d.qr <- qr(taper.real[1:(fCut), ])
  coefs <- qr.coef(d.qr, rep(1, fCut))
  
  fitted <- qr.fitted(d.qr, rep(1, fCut))
  
  filter1 <- slep.tmp %*% coefs
  filter2 <- filter1 / sum(filter1)
  
  # H <- fft(c(filter2, rep(0, M - nflt)))[1:(M/2+1)]
  # plot(abs(H)[1:1000]^2, type='l', log='y')
  
  filter2
}

findGaps <- function(data, missingSignature=NA){
  nas <- data %in% missingSignature
  N <- length(data)
  
  if (N == 0){
    stop("Data of length 0.")
  }
  
  x <- 1:N
  gaps <- c(0, 0, 0)
  numGaps <- 0
  
  i <- 1
  while (i <= N){
    gapLength <- 0
    
    while(nas[i+gapLength] && (i+gapLength <= length(nas))){
      gapLength <- gapLength + 1
    }
    
    if (gapLength > 0){
      gaps <- rbind(gaps, c(i, i+gapLength-1, gapLength), deparse.level=0)
      i <- i + gapLength
      numGaps <- numGaps + 1
    } else { i <- i + 1 }
  }
  
  if (numGaps == 0){ 
    t(as.matrix(gaps))
  } else if (numGaps == 1) {
    t(as.matrix(gaps[-1,]))
  } else { as.matrix(gaps[-1,])}
}

.is.deriv <- function(obj){
  class(obj) == "dpssp"
}

.is.dpss <- function(obj){
  class(obj) == "dpss"
}

.is.ap <- function(obj){
  class(obj) == "ass.poly"
}

dpssp11R <- function(DW,NW){
  stopifnot(.is.dpss(DW))
  efn <- DW$v
  ev <- DW$eigen
  ndata <- nrow(efn)
  K <- ncol(efn)
  W <- NW / ndata
  tn <- 1:(ndata-1)
  
  b <- c(0, sin( 2*pi*W*tn) / (pi * tn^2) )
  a <- 2 * W * c(0, cos( 2*pi*W*tn ) / tn )
  y <- a - b
  
  #this is multiplication by a skew-symmetric toeplitz matrix.
  # the matrix is skew.toeplitz(y, upper = TRUE), meaning that 
  # we actually need to negate different stuff.justification on 9 June 2020 notes. 
  #if the skew-symmetric matrix generated by y is C, then the first row of C is 
  # C[1,] = c(y[1], -y[2:n]). then the relevant line from skew.toepmult is 
  #x <- as.matrix(c(C[1,1], -C[1,2:n], 0, C[1,n:2])), which is equivalent to
  #x <- as.matrix(c(y[1], y[2:n], 0, -y[n:2])), or x <- as.matrix(c(y,0,-y[n:2]))
  efnp <- matrix(data = NA, nrow = ndata, ncol = K)
  x <- as.matrix(c(y,0,-y[ndata:2]))
  for(k in 1:K){
    p <- c(efn[,k],rep(0,ndata))
    h <- as.vector(fft(p)*fft(x))
    efnp[,k] <- Re(fft(h, inverse = TRUE)[1:ndata] / length(h)) / ev[k] 
  }
  
  class(efnp) <- "dpssp"
  return(efnp)
}

findLocalFMaxM <- function(obj, k, cutoff){
  
  M <- nrow(obj)
  stopifnot(k > M)
  MAXES <- list()
  for(m in 1:M){
    Fval <- obj[m,]
    fMaxInd <- which(Fval > qf(cutoff, 1, k-m))
    maxes <- c()
    
    if (length(fMaxInd) == 0){
      next
    }
    
    for (i in 1:length(fMaxInd)){
      if (fMaxInd[i] == 1 || fMaxInd[i] == length(Fval)){
        next
      }
      
      if (Fval[fMaxInd[i]] > Fval[fMaxInd[i]-1] && 
          Fval[fMaxInd[i]] > Fval[fMaxInd[i]+1]){
        maxes <- c(maxes, fMaxInd[i])
      }
    }
    MAXES[[m]] <- maxes
  }
  return(MAXES)
}


FLoop3 <- function(mxdeg, nord, FPcoef, Fcoef, nfreqs){
  output <- .Fortran("Floop3", 
                     mxdeg = as.integer(mxdeg),
                     nord = as.integer(nord),
                     FPcoef = as.double(FPcoef),
                     Fcoef = as.double(Fcoef),
                     Fp = double( (mxdeg+1)*nfreqs ),
                     nfreqs = as.integer(nfreqs)
  )
  Fp <- matrix(data = output$Fp, nrow = mxdeg+1, ncol = nfreqs)
}

inverseScales <- function(V, Vdot){
  scl1 <- rowSums(V^2)
  scl2 <- rowSums(Vdot^2)
  scl3 <- rowSums(V*Vdot)^2 / (scl1 * scl2)
  
  scl <- 2*pi*sqrt(scl1) / sqrt( scl2 * (1 - scl3) )
  out <- list(scl = scl, scl1 = scl1, scl2 = scl2, scl3 = scl3)
  return(out)
}

assPolySmoother <- function(AP, V, Vdot, smooth = 0){
  H <- AP$U
  G <- AP$R
  D <- AP$D
  k <- nrow(H)
  
  Hproj <- diag(x=1, nrow = k) - tcrossprod(H[,1:(smooth+1), drop = FALSE])
  Gproj <- tcrossprod(G[,1:(smooth+1), drop = FALSE], H[,1:(smooth+1), drop = FALSE])
  A <- tcrossprod(V, Hproj) + Gproj
  
  Dproj <- tcrossprod(D[,1:(smooth+1), drop = FALSE], H[,1:(smooth+1), drop = FALSE])
  Adot <- tcrossprod(Vdot, Hproj) + Dproj
  
  out = list(A=A, Adot=Adot)
  return(out)
}

dpssapD <- function(V, maxdeg, alpha=0.75, deriv = FALSE) {
  
  # Sanity checks
  stopifnot(is.matrix(V), is.numeric(maxdeg), maxdeg>=0)
  N <- length(V[, 1])
  K <- length(V[1, ])
  P <- maxdeg + 1
  timeArr <- 1:N
  
  if(!deriv){
    R <- matrix(data=0, nrow=N, ncol=P)
    U <- matrix(data=0, nrow=K, ncol=P)
    D <- NULL
    
    # Setup centered time index
    midTime <- (1+N) / 2
    scl <- 2/(N-1)
    timeArrC <- (timeArr - midTime) * scl
    
    # Start with Gegenbauer polynomials; convergence is faster
    #alpha <- 0.75
    R[, 1] <- 1.0
    if(maxdeg > 0) {
      R[, 2] <- 2 * alpha * timeArrC
      if(maxdeg > 1) {
        for(j in 2:maxdeg) {
          A1 <- 2 * ( (j-1) + alpha ) / j
          A2 <- ( (j-2) + 2 * alpha ) / j
          
          R[, (j+1)] <- A1 * timeArrC * R[, j] - A2 * R[, (j-1)]
        } # end of loop on higher orders
      } # end of maxdeg > 1
    } # end of maxdeg > 0
    
    # Inner Products of R and V
    for(L in 1:P) {
      Kmin <- ( (L-1) %% 2 ) + 1
      for(k in seq(Kmin, K, 2)) {  # loop on non-zero Slepians
        U[k, L] <- t(V[, k]) %*% R[, L]
      }
    }
    
    
    
    # Degree 0, 1 (manual) -- L = degree+1
    for(L in 1:min(2,P)) {
      scl <- 1 / sqrt( sum(U[, L]^2) )
      U[, L] <- U[, L] * scl # orthonormalize
      R[, L] <- R[, L] * scl
    }
    
    # loop on higher degrees, applying Gram-Schmidt only on similar
    # parity functions (as even/odd are already orthogonal in U)
    if( P > 2 ) {
      for(L in 3:P) {
        if(L %% 2 == 0) {
          Kmin <- 2
        } else {
          Kmin <- 1
        }
        for(j in seq(Kmin, L-1, 2)) {
          scl <- sum( U[, L] * U[, j] )
          U[, L] <- U[, L] - scl * U[, j] # Gram-Schmidt
          R[, L] <- R[, L] - scl * R[, j]
        }
        scl <- 1 / sqrt(sum(U[, L]^2))
        U[, L] <- U[, L] * scl  # orthonormalize
        R[, L] <- R[, L] * scl
      }
    }
  }  else {
    R <- D <- matrix(data=0, nrow=N, ncol=P)
    U <- matrix(data=0, nrow=K, ncol=P)
    
    
    # Setup centered time index
    midTime <- (1+N) / 2
    tscl <- 2/(N-1)
    timeArrC <- (timeArr - midTime) * tscl
    
    # Start with Gegenbauer polynomials; convergence is faster
    #alpha <- 0.75
    R[, 1] <- 1.0
    if(maxdeg > 0) {
      R[, 2] <- 2 * alpha * timeArrC
      D[, 2] <- tscl 
      if(maxdeg > 1) {
        for(j in 2:maxdeg) {
          A1 <- 2 * ( (j-1) + alpha ) / j
          A2 <- ( (j-2) + 2 * alpha ) / j
          
          R[, (j+1)] <- A1 * timeArrC * R[, j] - A2 * R[, (j-1)]
          D[, (j+1)] <- tscl * j * R[, j]
        } # end of loop on higher orders
      } # end of maxdeg > 1
    } # end of maxdeg > 0
    
    # Inner Products of R and V
    for(L in 1:P) {
      Kmin <- ( (L-1) %% 2 ) + 1
      for(k in seq(Kmin, K, 2)) {  # loop on non-zero Slepians
        U[k, L] <- t(V[, k]) %*% R[, L]
      }
    }
    
    
    
    # Degree 0, 1 (manual) -- L = degree+1
    for(L in 1:min(2,P)) {
      scl <- 1 / sqrt( sum(U[, L]^2) )
      U[, L] <- U[, L] * scl # orthonormalize
      R[, L] <- R[, L] * scl
      D[, L] <- D[, L] * scl
    }
    
    
    
    # loop on higher degrees, applying Gram-Schmidt only on similar
    # parity functions (as even/odd are already orthogonal in U)
    if( P > 2 ) {
      for(L in 3:P) {
        if(L %% 2 == 0) {
          Kmin <- 2
        } else {
          Kmin <- 1
        }
        for(j in seq(Kmin, L-1, 2)) {
          scl <- sum( U[, L] * U[, j] )
          U[, L] <- U[, L] - scl * U[, j] # Gram-Schmidt
          R[, L] <- R[, L] - scl * R[, j]
          D[, L] <- D[, L] - scl * D[, j]
        }
        scl <- 1 / sqrt(sum(U[, L]^2))
        U[, L] <- U[, L] * scl  # orthonormalize
        R[, L] <- R[, L] * scl
        D[, L] <- D[, L] * scl
      }
    }
  }  
  
  Hn <- colSums(R^2)
  ap <- list(U=U,R=R,D=D,Hn=Hn)
  class(ap) <- "ass.poly"
  return(ap)
}

modulatedFs5 <- function(Phi,PhiP){
  P <- nrow(PhiP)
  K <- nrow(Phi)
  stopifnot(K > P)
  
  F1 <- F3 <- matrix(data = NA, nrow = P, ncol = ncol(Phi))
  ssq1 <- colSums(Phi^2)
  ssq2 <- 0
  
  for(p in 1:P){
    ssq2 <- ssq2 + PhiP[p,]^2
    F1[p,] <- (K/p - 1) * ssq2 / (ssq1 - ssq2)
    F3[p,] <- (K - p) * PhiP[p,]^2 / (ssq1 - ssq2)
  }
  
  return(list(F1=F1,F3=F3))
}


ModulatedF17 <- function(yk, derivIN = NULL, apIN = NULL, dpssIN = NULL){
  
  #speed version of this function. everything must be passed in.
  K <- ncol(yk)
  V <- dpssIN$v
  H <- apIN$U
  P <- ncol(H)
  nfreqs <- nrow(yk)
  stopifnot(K > P)
  
  #############################################################################
  
  phi <- IFcompute(yk,V,derivIN)
  
  
  Phi <- crossprod(V,phi)
  rm(phi)
  PhiP <- crossprod(H,Phi)
  
  F3 <- FLoop3(P-1,K,PhiP,Phi,nfreqs)
  
  mFs <- modulatedFs5(Phi,PhiP[2:P,,drop = FALSE])
  mF1 <- mFs$F1
  mF3 <- mFs$F3
  
  
  ModF <- list(F3=F3,mF1=mF1,mF3=mF3)
  
  return(ModF)
  
}

HarmonicF <- function(yk, dw){
  
  k <- ncol(yk)
  Ukz <- colSums(dw)
  ssqUkz <- sum(Ukz^2)
  cmv <- (yk %*% Ukz) / ssqUkz
  ssqave <- ssqUkz * Mod(cmv)^2
  Ukz <- as.matrix(Ukz)
  
  ssqres <- apply( Mod(yk - (cmv %*% t(Ukz)))^2, MARGIN = 1, FUN = sum)
  HF <- (k-1) * ssqave / ssqres
  class(HF) <- "Ftest"
  
  out <- list(HF = HF, cmv = cmv)
  
  return(out)
}

FLoop4 <- function(mxdeg, nord, FPcoef, Fcoef, nfreqs){
  output <- .Fortran("FLoop4", 
                     mxdeg = as.integer(mxdeg),
                     nord = as.integer(nord),
                     FPcoef = as.double(FPcoef),
                     Fcoef = as.double(Fcoef),
                     Fp = double( mxdeg*nfreqs ),
                     nfreqs = as.integer(nfreqs)
  )
  Fp <- matrix(data = output$Fp, nrow = mxdeg, ncol = nfreqs)
}

IFcompute <- function(yk, V, Vdot){
  U <- tcrossprod(V, Re(yk))
  W <- tcrossprod(V, Im(yk))
  Udot <- tcrossprod(Vdot, Re(yk))
  Wdot <- tcrossprod(Vdot, Im(yk))
  
  num <- U*Wdot - Udot*W
  rm(Udot, Wdot)
  amp2 <- U^2 + W^2
  rm(U,W)
  
  phi <- num / (2 * pi * amp2)
  
  return(phi)
}

jkFreq <- function(Phi, H, freq){
  K <- nrow(H)
  P <- ncol(H)
  stopifnot(K > P)
  
  F3 <- matrix(0, nrow = P, ncol = length(freq))
  fkp <- matrix(0, nrow = K, ncol = P)
  for(k in 1:K){
    ssq1 <- colSums( Phi[-k,]^2 )
    PhiP <- crossprod(H[-k,], Phi[-k,])
    ssq2 <- 0
    for(p in 1:P){
      ssq2 <- ssq2 + PhiP[p,]^2
      F3[p,] <- (K-1-p) * PhiP[p,]^2 / (ssq1 - ssq2)
      fkp[k,p] <- freq[which.max(F3[p,])]
    }
  }
  jkMean <- apply(fkp, MARGIN = 2, FUN = function(x) mean(x))
  jkVar <- numeric(P)
  for(p in 1:P){
    jkVar[p] <- (1-1/K) * sum( (fkp[,p] - jkMean[p])^2 )
  }
  
  jk <- list(jkMean = jkMean, jkVar = jkVar)
  return(jk)
}

ModulatedF19 <- function(yk, derivIN = NULL, apIN = NULL, dpssIN = NULL,
                         deltat = 1, freq){
  
  #speed version of this function. everything must be passed in.
  #just computes modified F3. note that H matrix is missing first column,
  #the zero degree column.
  # also does jackknife estimates of mean and variance of frequency
  K <- ncol(yk)
  V <- dpssIN$v
  H <- apIN$U[,-1, drop = FALSE]
  P <- ncol(H)
  
  stopifnot(K > P)
  nfreqs <- nrow(yk)
  #############################################################################
  
  phi <- IFcompute(yk, V, derivIN)
  
  Phi <- crossprod(V,phi)
  rm(phi)
  PhiP <- crossprod(H,Phi)
  
  mF3 <- FLoop4(mxdeg,K,PhiP,Phi,nfreqs)
  jk <- jkFreq(Phi,H,freq)
  
  ModF <- list(mF3 = mF3, jk = jk)
  
  return(ModF)
  
}


ModulatedF20 <- function(yk, derivIN = NULL, apIN = NULL, dpssIN = NULL){
  
  #speed version of this function. everything must be passed in.
  #computes all 4 test statistics
  K <- ncol(yk)
  V <- dpssIN$v
  H <- apIN$U
  P <- ncol(H)
  #############################################################################
  
  phi <- IFcompute(yk, V, derivIN)
  
  Phi <- crossprod(V,phi)
  rm(phi)
  PhiP <- crossprod(H,Phi)
  
  Fs <- modulatedFs5(Phi, PhiP)
  mFs <- modulatedFs5(Phi, PhiP[2:P,,drop = FALSE])
  
  ModF <- list(F1 = Fs$F1, F3 = Fs$F3, mF1 = mFs$F1, mF3 = mFs$F3)
  
  return(ModF)
  
}

findLocalFMax2 <- function(obj, cutoff, k){
  # Check whether this is a spec.mtm() object, or from my own CMV code.
  if (any(class(obj) == "Ftest")){
    Fval <- obj
  }  else {
    stop("obj needs to be of class 'Ftest'.")
  }
  
  
  fMaxInd <- which(Fval > qf(cutoff, 2, 2*k-2))
  maxes <- c()
  
  if (length(fMaxInd) == 0){
    return(maxes)
  }
  
  for (i in 1:length(fMaxInd)){
    if (fMaxInd[i] == 1 || fMaxInd[i] == length(Fval)){
      next
    }
    
    if (Fval[fMaxInd[i]] > Fval[fMaxInd[i]-1] && 
        Fval[fMaxInd[i]] > Fval[fMaxInd[i]+1]){
      maxes <- c(maxes, fMaxInd[i])
    }
  }
  
  maxes
}
